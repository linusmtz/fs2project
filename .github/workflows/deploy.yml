name: Deploy to Production

on:
  push:
    branches:
      - main
      - master
  workflow_dispatch:

jobs:
  deploy:
    name: Deploy to Server
    runs-on: self-hosted  # Cambia esto por el label de tu runner si es diferente
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Copy code to deployment directory
        run: |
          set -e
          APP_DIR="/home/ubuntu/fs2Project"
          mkdir -p "$APP_DIR"
          
          echo "ðŸ“¦ Copiando cÃ³digo al directorio de deployment..."
          # Copiar todo el cÃ³digo desde el workspace del runner al directorio de deployment
          # Excluir staticfiles y logs ya que se generan automÃ¡ticamente y tienen permisos especiales
          rsync -av --delete \
            --exclude='.git' \
            --exclude='node_modules' \
            --exclude='__pycache__' \
            --exclude='*.pyc' \
            --exclude='.env' \
            --exclude='src/staticfiles/' \
            --exclude='src/logs/' \
            --exclude='src/media/' \
            "$GITHUB_WORKSPACE/" "$APP_DIR/"
          
          echo "APP_DIR=$APP_DIR" >> $GITHUB_ENV
          echo "âœ… CÃ³digo copiado exitosamente"

      - name: Create .env file from GitHub Secrets
        env:
          SECRET_KEY: ${{ secrets.SECRET_KEY }}
          DEBUG: ${{ secrets.DEBUG }}
          ALLOWED_HOSTS: ${{ secrets.ALLOWED_HOSTS }}
          CSRF_TRUSTED_ORIGINS: ${{ secrets.CSRF_TRUSTED_ORIGINS }}
          DJANGO_USE_SQLITE: ${{ secrets.DJANGO_USE_SQLITE }}
          POSTGRES_DB: ${{ secrets.POSTGRES_DB }}
          POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_HOST: ${{ secrets.POSTGRES_HOST }}
          POSTGRES_PORT: ${{ secrets.POSTGRES_PORT }}
          USE_CLOUD_STORAGE: ${{ secrets.USE_CLOUD_STORAGE }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_STORAGE_BUCKET_NAME: ${{ secrets.AWS_STORAGE_BUCKET_NAME }}
          AWS_S3_REGION_NAME: ${{ secrets.AWS_S3_REGION_NAME }}
          AWS_S3_ENDPOINT_URL: ${{ secrets.AWS_S3_ENDPOINT_URL }}
          TIME_ZONE: ${{ secrets.TIME_ZONE }}
          EMAIL_BACKEND: ${{ secrets.EMAIL_BACKEND }}
          EMAIL_HOST: ${{ secrets.EMAIL_HOST }}
          EMAIL_PORT: ${{ secrets.EMAIL_PORT }}
          EMAIL_USE_TLS: ${{ secrets.EMAIL_USE_TLS }}
          EMAIL_USE_SSL: ${{ secrets.EMAIL_USE_SSL }}
          EMAIL_HOST_USER: ${{ secrets.EMAIL_HOST_USER }}
          EMAIL_HOST_PASSWORD: ${{ secrets.EMAIL_HOST_PASSWORD }}
          DEFAULT_FROM_EMAIL: ${{ secrets.DEFAULT_FROM_EMAIL }}
          EMAIL_TIMEOUT: ${{ secrets.EMAIL_TIMEOUT }}
        run: |
          set -e
          cd "$APP_DIR"
          
          echo "ðŸ“ Creando archivo .env desde GitHub Secrets..."
          
          # Crear el archivo .env con todas las variables de los secrets
          cat > src/.env << EOF
          # Django Settings
          SECRET_KEY=${SECRET_KEY}
          DEBUG=${DEBUG:-0}
          ALLOWED_HOSTS=${ALLOWED_HOSTS}
          CSRF_TRUSTED_ORIGINS=${CSRF_TRUSTED_ORIGINS}
          
          # Database Configuration
          DJANGO_USE_SQLITE=${DJANGO_USE_SQLITE:-0}
          POSTGRES_DB=${POSTGRES_DB}
          POSTGRES_USER=${POSTGRES_USER}
          POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
          POSTGRES_HOST=${POSTGRES_HOST:-db}
          POSTGRES_PORT=${POSTGRES_PORT:-5432}
          
          # Cloud Storage (OCI Object Storage)
          USE_CLOUD_STORAGE=${USE_CLOUD_STORAGE:-1}
          AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
          AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
          AWS_STORAGE_BUCKET_NAME=${AWS_STORAGE_BUCKET_NAME}
          AWS_S3_REGION_NAME=${AWS_S3_REGION_NAME}
          AWS_S3_ENDPOINT_URL=${AWS_S3_ENDPOINT_URL}
          
          # Optional Settings
          TIME_ZONE=${TIME_ZONE:-America/Mexico_City}
          
          # Email Configuration
          EMAIL_BACKEND=${EMAIL_BACKEND:-django.core.mail.backends.console.EmailBackend}
          EMAIL_HOST=${EMAIL_HOST:-}
          EMAIL_PORT=${EMAIL_PORT:-587}
          EMAIL_USE_TLS=${EMAIL_USE_TLS:-True}
          EMAIL_USE_SSL=${EMAIL_USE_SSL:-False}
          EMAIL_HOST_USER=${EMAIL_HOST_USER:-}
          EMAIL_HOST_PASSWORD=${EMAIL_HOST_PASSWORD:-}
          DEFAULT_FROM_EMAIL=${DEFAULT_FROM_EMAIL:-noreply@example.com}
          EMAIL_TIMEOUT=${EMAIL_TIMEOUT:-10}
          EOF
          
          # Verificar que las variables crÃ­ticas estÃ©n configuradas
          echo "ðŸ” Verificando variables crÃ­ticas..."
          
          REQUIRED_VARS=(
            "SECRET_KEY"
            "ALLOWED_HOSTS"
            "POSTGRES_DB"
            "POSTGRES_USER"
            "POSTGRES_PASSWORD"
            "AWS_ACCESS_KEY_ID"
            "AWS_SECRET_ACCESS_KEY"
            "AWS_STORAGE_BUCKET_NAME"
            "AWS_S3_REGION_NAME"
            "AWS_S3_ENDPOINT_URL"
          )
          
          MISSING_VARS=()
          for var in "${REQUIRED_VARS[@]}"; do
            if ! grep -q "^${var}=" src/.env || grep -q "^${var}=$" src/.env || grep -q "^${var}=\$" src/.env; then
              MISSING_VARS+=("$var")
            fi
          done
          
          if [ ${#MISSING_VARS[@]} -gt 0 ]; then
            echo "âŒ ERROR: Faltan las siguientes variables en GitHub Secrets:"
            printf '  - %s\n' "${MISSING_VARS[@]}"
            exit 1
          fi
          
          # Asegurar que la IP pÃºblica estÃ© en ALLOWED_HOSTS
          echo "ðŸ”§ Verificando ALLOWED_HOSTS..."
          if ! grep -q "129.80.212.133" src/.env || ! grep -q "^ALLOWED_HOSTS=.*129.80.212.133" src/.env; then
            echo "âž• Agregando IP pÃºblica a ALLOWED_HOSTS..."
            sed -i 's/^ALLOWED_HOSTS=\(.*\)$/ALLOWED_HOSTS=\1,129.80.212.133/' src/.env
            # Si no existÃ­a ALLOWED_HOSTS, agregarlo
            if ! grep -q "^ALLOWED_HOSTS=" src/.env; then
              sed -i '/^# Django Settings/a ALLOWED_HOSTS=app.linusmartinez.com,localhost,127.0.0.1,129.80.212.133' src/.env
            fi
          fi
          
          # Asegurar que la IP estÃ© en CSRF_TRUSTED_ORIGINS
          if ! grep -q "http://129.80.212.133" src/.env || ! grep -q "^CSRF_TRUSTED_ORIGINS=.*http://129.80.212.133" src/.env; then
            echo "âž• Agregando IP pÃºblica a CSRF_TRUSTED_ORIGINS..."
            if grep -q "^CSRF_TRUSTED_ORIGINS=" src/.env; then
              sed -i 's|^CSRF_TRUSTED_ORIGINS=\(.*\)$|CSRF_TRUSTED_ORIGINS=\1,http://129.80.212.133|' src/.env
            else
              sed -i '/^ALLOWED_HOSTS=/a CSRF_TRUSTED_ORIGINS=http://app.linusmartinez.com,http://129.80.212.133' src/.env
            fi
          fi
          
          # Proteger el archivo .env
          chmod 600 src/.env
          echo "âœ… Archivo .env creado exitosamente y protegido"

      - name: Build and start containers
        run: |
          set -e
          cd "$APP_DIR"
          
          echo "ðŸ”¨ Construyendo contenedores..."
          docker compose -f docker-compose.prod.yml build --no-cache
          
          echo "ðŸš€ Levantando contenedores..."
          docker compose -f docker-compose.prod.yml up -d
          
          echo "â³ Esperando a que los servicios estÃ©n listos..."
          sleep 15

      - name: Run migrations
        run: |
          cd "$APP_DIR"
          echo "ðŸ“Š Ejecutando migraciones..."
          docker compose -f docker-compose.prod.yml exec -T web python manage.py migrate --noinput

      - name: Collect static files
        run: |
          cd "$APP_DIR"
          echo "ðŸ“¦ Recopilando archivos estÃ¡ticos..."
          
          # Asegurar que los directorios existen con permisos correctos
          sudo mkdir -p "$APP_DIR/src/staticfiles"
          sudo mkdir -p "$APP_DIR/src/logs"
          sudo mkdir -p "$APP_DIR/src/media"
          
          # Ejecutar collectstatic
          docker compose -f docker-compose.prod.yml exec -T web python manage.py collectstatic --noinput
          
          echo "ðŸ”§ Ajustando permisos de archivos estÃ¡ticos para Nginx..."
          sudo chown -R www-data:www-data "$APP_DIR/src/staticfiles/"
          sudo chmod -R 755 "$APP_DIR/src/staticfiles/"
          sudo chmod 755 "$APP_DIR/src/" "$APP_DIR/src/staticfiles/"

      - name: Verify containers
        run: |
          cd "$APP_DIR"
          echo "âœ… Verificando contenedores..."
          docker compose -f docker-compose.prod.yml ps

      - name: Clean up old images
        run: |
          echo "ðŸ§¹ Limpiando imÃ¡genes antiguas..."
          docker image prune -f

      - name: Verify deployment
        run: |
          sleep 5
          curl -f http://localhost:8000/ || echo "âš ï¸ Advertencia: No se pudo verificar el deployment localmente"
          echo "âœ… Deployment completado exitosamente!"

